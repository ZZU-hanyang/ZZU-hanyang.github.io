<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>函数重载</title>
    <link href="/2021/12/03/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"/>
    <url>/2021/12/03/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h3 id="作用：函数名可以相同，提高了同一个函数名的复用xing"><a href="#作用：函数名可以相同，提高了同一个函数名的复用xing" class="headerlink" title="作用：函数名可以相同，提高了同一个函数名的复用xing"></a>作用：函数名可以相同，提高了同一个函数名的复用xing</h3><h4 id="满足条件："><a href="#满足条件：" class="headerlink" title="满足条件："></a>满足条件：</h4><h4 id="1、在同一个作用域下"><a href="#1、在同一个作用域下" class="headerlink" title="1、在同一个作用域下"></a>1、在同一个作用域下</h4><h4 id="2、函数名相同"><a href="#2、函数名相同" class="headerlink" title="2、函数名相同"></a>2、函数名相同</h4><h4 id="3、函数的参数类型、参数个数或者参数顺序不同"><a href="#3、函数的参数类型、参数个数或者参数顺序不同" class="headerlink" title="3、函数的参数类型、参数个数或者参数顺序不同"></a>3、函数的参数类型、参数个数或者参数顺序不同</h4><h4 id="满足以上条件均可实现函数重载"><a href="#满足以上条件均可实现函数重载" class="headerlink" title="满足以上条件均可实现函数重载"></a>满足以上条件均可实现函数重载</h4><h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h3><pre><code>//为了用同一个函数名执行不同的操作，可以让函数进行重载void func()//无参数传入的函数调用 &#123;    cout&lt;&lt;&quot;func()的调用&quot;&lt;&lt;endl;&#125; void func(int a)//传入一个整型数据的函数调用 &#123;    cout&lt;&lt;&quot;func(int a)的调用&quot;&lt;&lt;endl;  &#125; void func(double a)//传入一个double类型数据的函数调用 &#123;    cout&lt;&lt;&quot;func(double a)的调用&quot;&lt;&lt;endl; &#125;void func(int a,double b)//依次传入一个int和一个double类型数据的调用 &#123;    cout&lt;&lt;&quot;func(int a,double b)的调用&quot;&lt;&lt;endl;     &#125; void func(double a,int b)//依次传入一个double和一个int类型数据的调用 &#123;    cout&lt;&lt;&quot;func(double a,int b)的调用&quot;&lt;&lt;endl; &#125;  </code></pre><hr><h4 id="特别注意："><a href="#特别注意：" class="headerlink" title="特别注意："></a>特别注意：</h4><pre><code>//这种情况不满足函数重载的条件，因为func函数的返回类型和其他的同名函数不同//在编译时就会产生歧义(既可以被理解成调用void func()函数，也可以被理解成调用 int func()函数) int void fun()&#123;    cout&lt;&lt;&quot;func()&quot;&lt;&lt;endl; &#125;</code></pre><hr><pre><code>在主函数中进行调用 func(); func(10); func(3.14); func(10,3.14); func(3.14,10);  这五个函数依次输出对应的函数体中的操作</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数的占位参数</title>
    <link href="/2021/12/03/%E5%87%BD%E6%95%B0%E7%9A%84%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0/"/>
    <url>/2021/12/03/%E5%87%BD%E6%95%B0%E7%9A%84%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="占位参数"><a href="#占位参数" class="headerlink" title="占位参数"></a>占位参数</h4><pre><code>C++中，函数的形参列表中可以有占位参数，用来作占位。调用函数的时候必须填补该占位处 的数据</code></pre><h4 id="语法：-返回值类型-函数名（数据类型）-…"><a href="#语法：-返回值类型-函数名（数据类型）-…" class="headerlink" title="语法： 返回值类型 函数名（数据类型）{…}"></a>语法： 返回值类型 函数名（数据类型）{…}</h4><h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><pre><code>//此处定义的函数不仅有一个参数a，还有一个int型的占位参数。 //在调用该函数的时候，不仅需要传入参数a，还要传入一个int型的数据 void func(int a,int)&#123;    return a*100;&#125;//在主函数中进行调用cout&lt;&lt;func(10，20)&lt;&lt;endl;</code></pre><h4 id="注意：占位参数也可以赋初始值"><a href="#注意：占位参数也可以赋初始值" class="headerlink" title="注意：占位参数也可以赋初始值"></a>注意：占位参数也可以赋初始值</h4><pre><code>例如：int func(int a,int = 10)&#123;    return a*100;&#125;//在主函数中进行调用cout&lt;&lt;func(5)&lt;&lt;endl;//此时占位参数就可以不用写，因为它已经被赋初始值了</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数默认参数</title>
    <link href="/2021/12/03/%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/"/>
    <url>/2021/12/03/%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="函数在声明或者实现的时候可以有默认参数"><a href="#函数在声明或者实现的时候可以有默认参数" class="headerlink" title="函数在声明或者实现的时候可以有默认参数"></a>函数在声明或者实现的时候可以有默认参数</h3><h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><pre><code>int func(int a,int b=10,int c=20)&#123;    return a+b+c;&#125;在主函数中进行调用cout&lt;&lt;func(10)&lt;&lt;endl; //输出的结果是10+10+20=40 cout&lt;&lt;func(10,20)&lt;&lt;endl;//输出的结果是10+20+20=50 </code></pre><h3 id="如果我们自己传入数据，那么函数体就调用传入的数据，否则就用默认值"><a href="#如果我们自己传入数据，那么函数体就调用传入的数据，否则就用默认值" class="headerlink" title="如果我们自己传入数据，那么函数体就调用传入的数据，否则就用默认值"></a>如果我们自己传入数据，那么函数体就调用传入的数据，否则就用默认值</h3><hr><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="1、在函数的参数中，如果某个位置的参数有了默认值，那么这个位置之后的所有参数都必须有默认值"><a href="#1、在函数的参数中，如果某个位置的参数有了默认值，那么这个位置之后的所有参数都必须有默认值" class="headerlink" title="1、在函数的参数中，如果某个位置的参数有了默认值，那么这个位置之后的所有参数都必须有默认值"></a>1、在函数的参数中，如果某个位置的参数有了默认值，那么这个位置之后的所有参数都必须有默认值</h4><pre><code>例如： func(int a,int b=10,int c)&#123;...&#125; 是错误的，因为b有了默认参数，那么c也必须有</code></pre><h4 id="2、函数的声明和实现只能有一方有默认参数。即函数在声明时有了默认参数，那么在函数实现的时候就不能有默认参数；同样，在函数实现的时候有了默认参数，那么在函数声明的时候就不能有默认参数。"><a href="#2、函数的声明和实现只能有一方有默认参数。即函数在声明时有了默认参数，那么在函数实现的时候就不能有默认参数；同样，在函数实现的时候有了默认参数，那么在函数声明的时候就不能有默认参数。" class="headerlink" title="2、函数的声明和实现只能有一方有默认参数。即函数在声明时有了默认参数，那么在函数实现的时候就不能有默认参数；同样，在函数实现的时候有了默认参数，那么在函数声明的时候就不能有默认参数。"></a>2、函数的声明和实现只能有一方有默认参数。即函数在声明时有了默认参数，那么在函数实现的时候就不能有默认参数；同样，在函数实现的时候有了默认参数，那么在函数声明的时候就不能有默认参数。</h4><pre><code>    例如：//声明一个函数func()int func(int a=10,int b=20);//func函数的实现int func(int a=10,int b=20)&#123;    return a+b;&#125; 或者int func(int a=1000,int b=1000)&#123;    return a+b;&#125; 这样写是错误的</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>引用做函数返回值</title>
    <link href="/2021/12/02/%E5%BC%95%E7%94%A8%E5%81%9A%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC/"/>
    <url>/2021/12/02/%E5%BC%95%E7%94%A8%E5%81%9A%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="不要返回局部变量的引用"><a href="#不要返回局部变量的引用" class="headerlink" title="不要返回局部变量的引用"></a>不要返回局部变量的引用</h3><h4 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h4><pre><code>int &amp;func1()&#123;    int a=10;    return a;//用引用的方式返回局部变量，即返回值是局部变量的别名 &#125;在主函数中进行调用：int &amp;p=func1();cout&lt;&lt;p&lt;&lt;endl;//第一次输出正确是因为编译器作了保留 cout&lt;&lt;p&lt;&lt;endl;//第二次输出错误是因为函数在执行完之后，局部变量占据的内存被释放了 </code></pre><h3 id="函数的调用可以作为左值"><a href="#函数的调用可以作为左值" class="headerlink" title="函数的调用可以作为左值"></a>函数的调用可以作为左值</h3><pre><code>int &amp;func2()&#123;    static int b=20;//静态变量，存放在全局区，全局区的数据会在程序结束后由系统释放掉     return b;&#125;在主函数中进行调用：int &amp;q=func2();//用引用的方式接收函数的返回值 cout&lt;&lt;q&lt;&lt;endl;cout&lt;&lt;q&lt;&lt;endl;//如果函数的返回值是引用，这个函数调用可以作为左值 func2()=1000;//此处的左值相当于静态变量b的别名，相当于对b进行赋值操作 cout&lt;&lt;q&lt;&lt;endl; </code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>引用做函数参数</title>
    <link href="/2021/12/02/%E5%BC%95%E7%94%A8%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/"/>
    <url>/2021/12/02/%E5%BC%95%E7%94%A8%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="三种参数传递方式："><a href="#三种参数传递方式：" class="headerlink" title="三种参数传递方式："></a>三种参数传递方式：</h3><h4 id="例如：交换函数"><a href="#例如：交换函数" class="headerlink" title="例如：交换函数"></a>例如：交换函数</h4><h3 id="1、值传递，形参不能修饰实参"><a href="#1、值传递，形参不能修饰实参" class="headerlink" title="1、值传递，形参不能修饰实参"></a>1、值传递，形参不能修饰实参</h3><pre><code>void swap1(int a,int b)&#123;    int temp;    temp=a;    a=b;    b=temp;    cout&lt;&lt;&quot;swap1中的a=&quot;&lt;&lt;a&lt;&lt;endl;    cout&lt;&lt;&quot;swap1中的b=&quot;&lt;&lt;b&lt;&lt;endl;&#125; </code></pre><h3 id="2、地址传递，形参能够修饰实参"><a href="#2、地址传递，形参能够修饰实参" class="headerlink" title="2、地址传递，形参能够修饰实参"></a>2、地址传递，形参能够修饰实参</h3><pre><code>    void swap2(int *a,int *b)&#123;    int temp;    temp=*a;    *a=*b;    *b=temp;    cout&lt;&lt;&quot;swap2中的a=&quot;&lt;&lt;a&lt;&lt;endl;    cout&lt;&lt;&quot;swap2中的b=&quot;&lt;&lt;b&lt;&lt;endl;&#125;</code></pre><h3 id="3、引用传递，形参能够修饰实参"><a href="#3、引用传递，形参能够修饰实参" class="headerlink" title="3、引用传递，形参能够修饰实参"></a>3、引用传递，形参能够修饰实参</h3><pre><code>void swap3(int &amp;a,int &amp;b)&#123;    int temp;    temp=a;    a=b;    b=temp;    cout&lt;&lt;&quot;swap3中的a=&quot;&lt;&lt;a&lt;&lt;endl;    cout&lt;&lt;&quot;swap3中的b=&quot;&lt;&lt;b&lt;&lt;endl;&#125;</code></pre><h3 id="在主函数调用时："><a href="#在主函数调用时：" class="headerlink" title="在主函数调用时："></a>在主函数调用时：</h3><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><h4 id="int-a-10-b-20"><a href="#int-a-10-b-20" class="headerlink" title="int a=10,b=20;"></a>int a=10,b=20;</h4><h4 id="swap-a-b"><a href="#swap-a-b" class="headerlink" title="swap(a,b);"></a>swap(a,b);</h4><h4 id="这里是用引用的方式传递变量a和b，只是原名和别名起的一样，依然可以实现交换变量a和b的功能"><a href="#这里是用引用的方式传递变量a和b，只是原名和别名起的一样，依然可以实现交换变量a和b的功能" class="headerlink" title="这里是用引用的方式传递变量a和b，只是原名和别名起的一样，依然可以实现交换变量a和b的功能"></a>这里是用引用的方式传递变量a和b，只是原名和别名起的一样，依然可以实现交换变量a和b的功能</h4><pre><code>cout&lt;&lt;&quot;主函数中的a=&quot;&lt;&lt;a&lt;&lt;endl;cout&lt;&lt;&quot;主函数中的b=&quot;&lt;&lt;b&lt;&lt;endl;//输出结果为主函数中 a=20,b=10;//在swap3函数中 a=20,b=20; </code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>引用</title>
    <link href="/2021/12/02/%E5%BC%95%E7%94%A8/"/>
    <url>/2021/12/02/%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="引用的作用"><a href="#引用的作用" class="headerlink" title="引用的作用"></a>引用的作用</h3><pre><code>作用：给变量起别名</code></pre><h3 id="引用的语法"><a href="#引用的语法" class="headerlink" title="引用的语法"></a>引用的语法</h3><pre><code>语法： 数据类型 &amp;别名 = 原名例如： int a=10; int &amp;b=a;  //a和b的值也是一样的 cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;&quot;b=&quot;&lt;&lt;b&lt;&lt;endl;   //输出的a和b的地址都是一样的 cout&lt;&lt;&quot;a的地址为：&quot;&lt;&lt;&amp;a&lt;&lt;endl; cout&lt;&lt;&quot;b的地址为：&quot;&lt;&lt;&amp;b&lt;&lt;endl;  //通过操作别名b也能更改a的值 b=20; cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;&quot;b=&quot;&lt;&lt;b&lt;&lt;endl;</code></pre><h3 id="引用的注意事项"><a href="#引用的注意事项" class="headerlink" title="引用的注意事项"></a>引用的注意事项</h3><h4 id="1、引用必须初始化"><a href="#1、引用必须初始化" class="headerlink" title="1、引用必须初始化"></a>1、引用必须初始化</h4><pre><code>例如：int &amp;b; //错误的int &amp;b=a;//正确的</code></pre><h4 id="2、引用一旦初始化之后就不能再更改"><a href="#2、引用一旦初始化之后就不能再更改" class="headerlink" title="2、引用一旦初始化之后就不能再更改"></a>2、引用一旦初始化之后就不能再更改</h4><pre><code>例如：int &amp;b=a;int &amp;b=c;//错误的</code></pre><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><pre><code>b=c;//这是赋值操作，是允许的，而不是更改引用</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存分区</title>
    <link href="/2021/12/02/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/"/>
    <url>/2021/12/02/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h2><h4 id="C-程序在执行的时候，会将内存大方向分为4个区域："><a href="#C-程序在执行的时候，会将内存大方向分为4个区域：" class="headerlink" title="C++程序在执行的时候，会将内存大方向分为4个区域："></a>C++程序在执行的时候，会将内存大方向分为4个区域：</h4><pre><code>1.代码区：存放函数体的二进制代码，由操作系统进行管理2.全局区：存放全局变量和静态变量以及常量3.栈区：由编译器自动分配和释放，存放函数的参数值、局部变量等4.堆区：由程序员分配和释放，若程序员不是放，程序结束时由操作系统进行回收</code></pre><h3 id="内四区的意义："><a href="#内四区的意义：" class="headerlink" title="内四区的意义："></a>内四区的意义：</h3><pre><code>不同区域存放不同的数据，赋予不同的生命周期，让我们更灵活地编程</code></pre><hr><h2 id="程序运行之前："><a href="#程序运行之前：" class="headerlink" title="程序运行之前："></a>程序运行之前：</h2><pre><code>在程序编译后，生成了exe可执行程序；未执行程序之前分为两个区域：</code></pre><h3 id="代码区："><a href="#代码区：" class="headerlink" title="代码区："></a>代码区：</h3><pre><code>1.存放CPU执行的机器指令。2.代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。3.代码区是只读的，使其只读的原因是防止程序在执行过程中意外地修改它原来的指令</code></pre><h3 id="全局区："><a href="#全局区：" class="headerlink" title="全局区："></a>全局区：</h3><pre><code>1.全局变量和静态变量存放在此。2.全局变量里还包含了常量区、字符串常量和其他常量也存放在此。3.该区域的数据在程序结束后由操作系统释放。</code></pre><hr><h2 id="程序运行之后"><a href="#程序运行之后" class="headerlink" title="程序运行之后"></a>程序运行之后</h2><pre><code>程序运行之后：</code></pre><h3 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h3><pre><code>1.不要返回局部变量的地址2.栈区的数据由编译器管理开辟和释放</code></pre><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><pre><code>int* func()&#123;    int a=10;//局部变量    return &amp;a; //返回局部变量的地址，栈区的数据在函数执行结束之后会被释放 &#125;int main()&#123;    //接收func函数的返回值    int *p=func();    //在执行完函数之后，栈区数据被释放，但是利用指针接收到了原栈区数据的地址     cout&lt;&lt;*p&lt;&lt;endl;//第一次输出正确是因为编译器对该地址指向的数据做了保留     cout&lt;&lt;*p&lt;&lt;endl; //第二次这个数据就不再保留，就会返回错误的值     system(&quot;pause&quot;);    return 0; &#125;</code></pre><h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><pre><code>1.由程序员进行分配和释放，若程序员不释放，程序结束时由操作系统进行回收2.在C++中主要利用关键字new在堆区开辟内存</code></pre><h4 id="堆区内存的开辟和释放"><a href="#堆区内存的开辟和释放" class="headerlink" title="堆区内存的开辟和释放"></a>堆区内存的开辟和释放</h4><pre><code>1.利用new关键字在堆区开辟内存空间的时候，返回的是该数据类型的指针  2.对应地释放该内存空间的时候，需要用关键字delete，内存被释放之后就不可再被访问 </code></pre><h5 id="单个数据的内存开辟"><a href="#单个数据的内存开辟" class="headerlink" title="单个数据的内存开辟"></a>单个数据的内存开辟</h5><h5 id="语法：数据类型-接收指针的变量名称-对应数据类型（数据）"><a href="#语法：数据类型-接收指针的变量名称-对应数据类型（数据）" class="headerlink" title="语法：数据类型 * 接收指针的变量名称 = 对应数据类型（数据）"></a>语法：数据类型 * 接收指针的变量名称 = 对应数据类型（数据）</h5><pre><code>例如：//在堆区创建整型数据，存储值为10int* func1()&#123;    //用指针a记录该内存的地址     int *a=new int(10);    return a;//函数的返回值是该内存的地址 &#125; 在主函数中进行调用int *p=func1();//func1 函数调用结束之后，虽然局部变量a消失了，但是a记录的值传了出来//在main函数中由指针p进行了接收，该值依然指向在堆区开辟的那一块内存  cout&lt;&lt;*p&lt;&lt;endl;cout&lt;&lt;*p&lt;&lt;endl;//两次调用的结果是一致的</code></pre><h5 id="数组内存的开辟"><a href="#数组内存的开辟" class="headerlink" title="数组内存的开辟"></a>数组内存的开辟</h5><h5 id="语法：数组类型-接收指针的变量名称-对应的数组类型-数组长度"><a href="#语法：数组类型-接收指针的变量名称-对应的数组类型-数组长度" class="headerlink" title="语法：数组类型 * 接收指针的变量名称 = 对应的数组类型[数组长度]"></a>语法：数组类型 * 接收指针的变量名称 = 对应的数组类型[数组长度]</h5><pre><code>例如：//在堆区开辟整型数组，数组长度为10 int* func2()&#123;    //用指针b接收该数组的地址    int *b=new int[10];    return b;&#125;//在主函数中进行调用int *q=func2(); //数组的访问 for(int i=0;i&lt;10;i++)//将在堆区开辟的数组赋值并输出 &#123;    q[i]=i+100;    cout&lt;&lt;q[i]&lt;&lt;endl;&#125;</code></pre><h6 id="单个数据内存的释放"><a href="#单个数据内存的释放" class="headerlink" title="单个数据内存的释放"></a>单个数据内存的释放</h6><h6 id="语法：delete-接收指针的变量名"><a href="#语法：delete-接收指针的变量名" class="headerlink" title="语法：delete 接收指针的变量名"></a>语法：delete 接收指针的变量名</h6><pre><code>delete p;</code></pre><h5 id="数组内存的释放"><a href="#数组内存的释放" class="headerlink" title="数组内存的释放"></a>数组内存的释放</h5><h5 id="语法：-delete-接收指针的变量名"><a href="#语法：-delete-接收指针的变量名" class="headerlink" title="语法： delete[] 接收指针的变量名"></a>语法： delete[] 接收指针的变量名</h5><pre><code>delete[] q;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>全局变量和局部变量</title>
    <link href="/2021/12/02/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"/>
    <url>/2021/12/02/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<pre><code>#include&lt;iostream&gt;using namespace std;//创建全局变量int g_a=10;int g_b=10; //const修饰的全局变量const int c_g_a=10;const int c_g_b=10; int main()&#123;    //创建普通局部变量    int a=10;    int b=10;    //静态变量     static int s_a=10;    static int s_b=10;     //常量    //字符串常量的地址    cout&lt;&lt;&quot;字符串常量hello的地址为：&quot;&lt;&lt;&amp;&quot;Hello&quot;&lt;&lt;endl;     //const修饰的常量分为：const修饰的全局变量和局部变量     //const修饰的局部变量     const int c_l_a=10;    const int c_l_b=10;    cout&lt;&lt;&quot;局部变量a的地址为：&quot;&lt;&lt;&amp;a&lt;&lt;endl;    cout&lt;&lt;&quot;局部变量b的地址为：&quot;&lt;&lt;&amp;b&lt;&lt;endl;    cout&lt;&lt;&quot;全局变量g_a的地址为：&quot;&lt;&lt;&amp;g_a&lt;&lt;endl;    cout&lt;&lt;&quot;全局变量g_b的地址为：&quot;&lt;&lt;&amp;g_b&lt;&lt;endl;    cout&lt;&lt;&quot;静态变量s_a的地址为：&quot;&lt;&lt;&amp;s_a&lt;&lt;endl;    cout&lt;&lt;&quot;静态变量s_b的地址为：&quot;&lt;&lt;&amp;s_b&lt;&lt;endl;    cout&lt;&lt;&quot;const修饰的全局变量c_g_a的地址为：&quot;&lt;&lt;&amp;c_g_a&lt;&lt;endl;    cout&lt;&lt;&quot;const修饰的全局变量c_g_b的地址为：&quot;&lt;&lt;&amp;c_g_b&lt;&lt;endl;    cout&lt;&lt;&quot;const修饰的局部变量c_l_a的地址为：&quot;&lt;&lt;&amp;c_l_a&lt;&lt;endl;    cout&lt;&lt;&quot;const修饰的局部变量c_l_b的地址为：&quot;&lt;&lt;&amp;c_l_b&lt;&lt;endl;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h3 id="局部变量、const修饰的局部变量（局部常量）都不在全局区。"><a href="#局部变量、const修饰的局部变量（局部常量）都不在全局区。" class="headerlink" title="局部变量、const修饰的局部变量（局部常量）都不在全局区。"></a>局部变量、const修饰的局部变量（局部常量）都不在全局区。</h3><h3 id="全局变量、静态变量、常量、字符串常量、const修饰的字符串常量都在全局区"><a href="#全局变量、静态变量、常量、字符串常量、const修饰的字符串常量都在全局区" class="headerlink" title="全局变量、静态变量、常量、字符串常量、const修饰的字符串常量都在全局区"></a>全局变量、静态变量、常量、字符串常量、const修饰的字符串常量都在全局区</h3>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通讯录</title>
    <link href="/2021/12/01/%E9%80%9A%E8%AE%AF%E5%BD%95/"/>
    <url>/2021/12/01/%E9%80%9A%E8%AE%AF%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="通讯录主函数"><a href="#通讯录主函数" class="headerlink" title="通讯录主函数"></a>通讯录主函数</h2><h3 id="addressBooks-cpp"><a href="#addressBooks-cpp" class="headerlink" title="addressBooks.cpp"></a>addressBooks.cpp</h3><pre><code>#include&lt;iostream&gt;    #include&lt;string&gt;#include &quot;function.h&quot;using namespace std;int main()&#123;    //初始化通讯录    struct addressBooks abs;    abs.m_Size = 0;    int select;    while (true)    &#123;        showMenu();        cin &gt;&gt; select;        switch (select)        &#123;        case 1:            addPerson(&amp;abs);//添加联系人            break;        case 2:            showPerson(&amp;abs);//显示联系人            break;        case 3:            deletePerson(&amp;abs);//删除联系人            break;        case 4:            searchPerson(&amp;abs);//查找联系人            break;        case 5:            recomposePerson(&amp;abs);//修改联系人            break;        case 6:            clearAddressBooks(&amp;abs);//清空通讯录            break;        case 0:        &#123;            cout &lt;&lt; &quot;退出成功&quot; &lt;&lt; endl;            return 0;            system(&quot;pause&quot;);            system(&quot;cls&quot;);        &#125;            break;        default:        &#123;            cout &lt;&lt; &quot;输入有误，请重新输入&quot; &lt;&lt; endl;            system(&quot;pause&quot;);            system(&quot;cls&quot;);        &#125;        &#125;    &#125;&#125;</code></pre><hr><h2 id="通讯录功能函数的头文件"><a href="#通讯录功能函数的头文件" class="headerlink" title="通讯录功能函数的头文件"></a>通讯录功能函数的头文件</h2><h3 id="function-h"><a href="#function-h" class="headerlink" title="function.h"></a>function.h</h3><pre><code>#pragma once#include&lt;iostream&gt;#include&lt;string&gt;#define MAX 100using namespace std;//定义联系人结构体struct Person&#123;    string m_Name;//姓名    int m_Sex;//性别 1代表男 2代表女    int m_Age;//年龄    string m_Phone;//电话    string m_Addr;//家庭住址&#125;;//定义通讯录结构体struct addressBooks&#123;    struct Person personArr[MAX];    int m_Size;&#125;;//显示菜单void showMenu();//输入某一个联系人的信息void inputPerson(struct Person* person);//输出某一个联系人的信息void outputPerson(struct Person* person);//1、添加联系人void addPerson(struct addressBooks* abs);//2、显示联系人void showPerson(struct addressBooks* abs);//3、删除联系人void deletePerson(struct addressBooks* abs);//4、查找联系人void searchPerson(struct addressBooks* abs);//5、修改联系人void recomposePerson(struct addressBooks* abs);//6 清空联系人void clearAddressBooks(struct addressBooks* abs);</code></pre><hr><h2 id="通讯录功能函数"><a href="#通讯录功能函数" class="headerlink" title="通讯录功能函数"></a>通讯录功能函数</h2><h2 id="function-cpp"><a href="#function-cpp" class="headerlink" title="function.cpp"></a>function.cpp</h2><pre><code>#include &quot;function.h&quot;//显示菜单栏void showMenu()&#123;    cout &lt;&lt; &quot;*********通讯录********&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;*****1、添加联系人*****&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;*****2、显示联系人*****&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;*****3、删除联系人*****&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;*****4、查找联系人*****&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;*****5、修改联系人*****&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;*****6、清空联系人*****&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;*****0、退出通讯录*****&quot; &lt;&lt; endl;&#125;//1、添加联系人void addPerson(struct addressBooks* abs)&#123;    if (abs-&gt;m_Size == MAX)    &#123;        cout &lt;&lt; &quot;当前通讯录已满&quot; &lt;&lt; endl;    &#125;    else    &#123;        inputPerson(&amp;(abs-&gt;personArr[abs-&gt;m_Size]));        abs-&gt;m_Size++;        cout &lt;&lt; &quot;添加成功&quot; &lt;&lt; endl;    &#125;    system(&quot;pause&quot;);    system(&quot;cls&quot;);&#125;//查找某一联系人是否存在int isExist(struct addressBooks* abs,string name)&#123;    int ret = -1;    for (int i = 0; i &lt; abs-&gt;m_Size; i++)    &#123;        if (abs-&gt;personArr[i].m_Name == name)        &#123;            ret = i;            break;        &#125;    &#125;    return ret;&#125;//输入某一联系人的信息void inputPerson(struct Person* person)&#123;    cout &lt;&lt; &quot;请输入联系人姓名：&quot; &lt;&lt; endl;    string name;    cin &gt;&gt; name;    person-&gt;m_Name = name;    cout &lt;&lt; &quot;请输入联系人年龄&quot; &lt;&lt; endl;    int age;    cin &gt;&gt; age;    person-&gt;m_Age = age;    cout &lt;&lt; &quot;请输入联系人性别&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;男---1&quot; &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;女---2&quot; &lt;&lt; endl;    int sex;    while (true)    &#123;        cin &gt;&gt; sex;        if (sex == 1 || sex == 2)        &#123;            person-&gt;m_Sex = sex;            break;        &#125;        cout &lt;&lt; &quot;输入有误，请重新输入&quot; &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;请输入联系人电话&quot; &lt;&lt; endl;    string phone;    cin &gt;&gt; phone;    person-&gt;m_Phone = phone;    cout &lt;&lt; &quot;请输入联系人家庭地址&quot; &lt;&lt; endl;    string address;    cin &gt;&gt; address;    person-&gt;m_Addr = address;&#125;//输出某一联系人的信息void outputPerson(struct Person* person)&#123;    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; person-&gt;m_Name &lt;&lt; endl;;    cout &lt;&lt; &quot;性别：&quot; &lt;&lt; ((person-&gt;m_Sex == 1) ? &quot;男&quot; : &quot;女&quot;) &lt;&lt; &quot;\t&quot;;    cout &lt;&lt; &quot;年龄：&quot; &lt;&lt; person-&gt;m_Age &lt;&lt; &quot;\t&quot;;    cout &lt;&lt; &quot;联系电话：&quot; &lt;&lt; person-&gt;m_Phone &lt;&lt; &quot;\t&quot;;    cout &lt;&lt; &quot;家庭住址：&quot; &lt;&lt; person-&gt;m_Addr &lt;&lt; endl;&#125;//2、显示联系人void showPerson(struct addressBooks* abs)&#123;    if (abs-&gt;m_Size == 0)    &#123;        cout &lt;&lt; &quot;当前通讯录为空&quot; &lt;&lt; endl;    &#125;    else    &#123;        for (int i = 0; i &lt; abs-&gt;m_Size; i++)        &#123;            outputPerson(&amp;(abs-&gt;personArr[i]));        &#125;    &#125;    system(&quot;pause&quot;);    system(&quot;cls&quot;);&#125;//3、删除联系人void deletePerson(struct addressBooks* abs)&#123;    cout &lt;&lt; &quot;请输入要删除的联系人姓名&quot; &lt;&lt; endl;    string name;    cin &gt;&gt; name;    int ret = isExist(abs, name);    if (ret == -1)    &#123;        cout &lt;&lt; &quot;此联系人不存在&quot; &lt;&lt; endl;    &#125;    else    &#123;        for (int i = ret; i &lt; abs-&gt;m_Size - 1; i++)        &#123;            abs-&gt;personArr[i] = abs-&gt;personArr[i + 1];        &#125;        abs-&gt;m_Size--;        cout &lt;&lt; &quot;删除成功&quot; &lt;&lt; endl;    &#125;    system(&quot;pause&quot;);    system(&quot;cls&quot;);&#125;//5、修改联系人void recomposePerson(struct addressBooks* abs)&#123;    cout &lt;&lt; &quot;请输入要修改的联系人姓名&quot; &lt;&lt; endl;    string name;    cin &gt;&gt; name;    int ret = isExist(abs, name);    if (ret == -1)    &#123;        cout &lt;&lt; &quot;此联系人不存在&quot; &lt;&lt; endl;    &#125;    else    &#123;        inputPerson(&amp;(abs-&gt;personArr[ret]));        cout &lt;&lt; &quot;修改成功&quot; &lt;&lt; endl;    &#125;    system(&quot;pause&quot;);    system(&quot;cls&quot;);&#125;//4、查找联系人void searchPerson(struct addressBooks* abs)&#123;    cout &lt;&lt; &quot;请输入要查找的联系人姓名&quot; &lt;&lt; endl;    string name;    cin &gt;&gt; name;    int ret = isExist(abs, name);    if (ret == -1)    &#123;        cout &lt;&lt; &quot;此联系人不存在&quot; &lt;&lt; endl;    &#125;    else    &#123;        outputPerson(&amp;(abs-&gt;personArr[ret]));    &#125;    system(&quot;pause&quot;);    system(&quot;cls&quot;);&#125;//6、清空联系人void clearAddressBooks(struct addressBooks* abs)&#123;    cout &lt;&lt; &quot;您确定要删除所有联系人吗&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;确定请输入Yes&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;取消请输入No&quot; &lt;&lt; endl;    string inputUser;    while (true)    &#123;        cin &gt;&gt; inputUser;        if (inputUser == &quot;Yes&quot;)        &#123;            abs-&gt;m_Size = 0;            cout &lt;&lt; &quot;清空成功&quot; &lt;&lt; endl;            break;        &#125;        else if (inputUser == &quot;No&quot;)        &#123;            cout &lt;&lt; &quot;取消成功&quot; &lt;&lt; endl;            break;        &#125;        cout &lt;&lt; &quot;输入有误，请重新输入&quot; &lt;&lt; endl;    &#125;    system(&quot;pause&quot;);    system(&quot;cls&quot;);&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构体做函数参数</title>
    <link href="/2021/11/27/%E7%BB%93%E6%9E%84%E4%BD%93%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/"/>
    <url>/2021/11/27/%E7%BB%93%E6%9E%84%E4%BD%93%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="地址传递"><a href="#地址传递" class="headerlink" title="地址传递"></a>地址传递</h3><h4 id="可以将结构体的地址传递进函数，在函数中对结构体进行访问和修改"><a href="#可以将结构体的地址传递进函数，在函数中对结构体进行访问和修改" class="headerlink" title="可以将结构体的地址传递进函数，在函数中对结构体进行访问和修改"></a>可以将结构体的地址传递进函数，在函数中对结构体进行访问和修改</h4><h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><h4 id="可以将结构体变量的值传递进函数，不能对结构体进行修改，相当于形参"><a href="#可以将结构体变量的值传递进函数，不能对结构体进行修改，相当于形参" class="headerlink" title="可以将结构体变量的值传递进函数，不能对结构体进行修改，相当于形参"></a>可以将结构体变量的值传递进函数，不能对结构体进行修改，相当于形参</h4><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;//定义一个结构体struct student&#123;    string name;    int age;    int score;&#125;; //两个打印学生信息函数的声明void printStudent1(student stu); void printStudent2(student *p);int main()&#123;    student s;    s.name=&quot;张三&quot;;    s.age=20;    s.score=80;    printStudent1(s);//值传递     printStudent2(&amp;s);//地址传递     cout&lt;&lt;&quot;在主函数中&quot;&lt;&lt;&quot; 姓名：&quot;&lt;&lt;s.name&lt;&lt;&quot; 年龄：&quot;&lt;&lt;s.age&lt;&lt;&quot; 分数：&quot;&lt;&lt;s.score&lt;&lt;endl;    system(&quot;pause&quot;);    return 0;&#125;//值传递 void printStudent1(student stu)&#123;    //对形参进行的修改    stu.name=&quot;李四&quot;;    cout&lt;&lt;&quot;在子函数1中&quot;&lt;&lt;&quot; 姓名：&quot;&lt;&lt;stu.name&lt;&lt;&quot; 年龄：&quot;&lt;&lt;stu.age&lt;&lt;&quot; 分数：&quot;&lt;&lt;stu.score&lt;&lt;endl; &#125;//地址传递 void printStudent2(student *p)&#123;    //对实参进行的修改    p-&gt;name=&quot;王五&quot;;    cout&lt;&lt;&quot;在子函数2中&quot;&lt;&lt;&quot; 姓名：&quot;&lt;&lt;p-&gt;name&lt;&lt;&quot; 年龄：&quot;&lt;&lt;p-&gt;age&lt;&lt;&quot; 分数：&quot;&lt;&lt;p-&gt;score&lt;&lt;endl;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构体的嵌套</title>
    <link href="/2021/11/27/%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%B5%8C%E5%A5%97/"/>
    <url>/2021/11/27/%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%B5%8C%E5%A5%97/</url>
    
    <content type="html"><![CDATA[<h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><h4 id="结构体的成员可以是另一个结构体"><a href="#结构体的成员可以是另一个结构体" class="headerlink" title="结构体的成员可以是另一个结构体"></a>结构体的成员可以是另一个结构体</h4><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;struct student&#123;    string name;//学生姓名     int age;//学生年龄     int score;//学生成绩 &#125; ; struct teacher &#123;    string name;//教师姓名     int ID;//职工编号     int age;//教师年龄     student stu;//教师辅导的学生 &#125;;int main()&#123;    teacher t;    t.name=&quot;老王&quot;;    t.ID=4396;    t.age=40;    t.stu.name=&quot;小王&quot;;    t.stu.age=18;    t.stu.score=100;     cout&lt;&lt;&quot;教师：&quot;&lt;&lt;t.name&lt;&lt;endl;     cout&lt;&lt;&quot;年龄：&quot;&lt;&lt;t.age&lt;&lt;endl;     cout&lt;&lt;&quot;职工编号：&quot;&lt;&lt;t.ID&lt;&lt;endl;     cout&lt;&lt;&quot;辅导学生：&quot;&lt;&lt;t.stu.name&lt;&lt;endl;     cout&lt;&lt;&quot;学生年龄：&quot;&lt;&lt;t.stu.age&lt;&lt;endl;     cout&lt;&lt;&quot;学生成绩：&quot;&lt;&lt;t.stu.score&lt;&lt;endl;     system(&quot;pause&quot;);    return 0;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构体指针</title>
    <link href="/2021/11/27/%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88/"/>
    <url>/2021/11/27/%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h3 id="1-定义结构体"><a href="#1-定义结构体" class="headerlink" title="1.定义结构体"></a>1.定义结构体</h3><pre><code>    struct student&#123;    string name;    int age;    int score;&#125;; </code></pre><h3 id="1-创建结构体指针"><a href="#1-创建结构体指针" class="headerlink" title="1.创建结构体指针"></a>1.创建结构体指针</h3><pre><code>//该结构体只有一个元素student Stu=&#123;&quot;张三&quot;,19,100&#125;;    </code></pre><h3 id="2-通过指针指向结构体变量"><a href="#2-通过指针指向结构体变量" class="headerlink" title="2.通过指针指向结构体变量"></a>2.通过指针指向结构体变量</h3><pre><code>    //通过结构体指针指向该结构体，该指针的类型和结构体一致    student *p = &amp;Stu;</code></pre><h3 id="3-通过指针访问结构体变量中的数据"><a href="#3-通过指针访问结构体变量中的数据" class="headerlink" title="3.通过指针访问结构体变量中的数据"></a>3.通过指针访问结构体变量中的数据</h3><pre><code>//通过指针访问结构体变量中的数据//需要用到  &quot;-&gt;&quot;  符号来进行操作 cout&lt;&lt;&quot;姓名：&quot;&lt;&lt;p-&gt;name&lt;&lt;endlcout&lt;&lt;&quot;年龄：&quot; &lt;&lt;p-&gt;age&lt;&lt;endlcout&lt;&lt;&quot;分数：&quot;&lt;&lt;p-&gt;score&lt;&lt;endl;</code></pre><h3 id="注意：-gt-是结构体指针访问结构体数据的符号"><a href="#注意：-gt-是结构体指针访问结构体数据的符号" class="headerlink" title="注意：  -&gt; 是结构体指针访问结构体数据的符号"></a>注意：  -&gt; 是结构体指针访问结构体数据的符号</h3>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构体</title>
    <link href="/2021/11/27/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <url>/2021/11/27/%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h3 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h3><pre><code>struct 结构体名&#123;    数据类型 数据名；        数据类型 数据名；        数据类型 数据名&#125;；</code></pre><h3 id="创建结构体数组"><a href="#创建结构体数组" class="headerlink" title="创建结构体数组"></a>创建结构体数组</h3><pre><code>struct 结构体名 数组名[元素个数]=&#123;    &#123;&#125;,    &#123;&#125;,        &#123;&#125;,        &#123;&#125;&#125;;</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>#include&lt;iostream&gt;#include&lt;string&gt; using namespace std;//结构体的定义struct student &#123;    string name;    int age;    int score;&#125;; int main()&#123;    //结构体的创建    struct student stuArray[4]=    &#123;        &#123;&quot;刘备&quot;,18,97&#125;,        &#123;&quot;关羽&quot;,20,90&#125;,        &#123;&quot;张飞&quot;,19,99&#125;,        &#123;&quot;赵云&quot;,21,98&#125;    &#125;;//结构体元素的赋值    stuArray[2].name=&quot;诸葛亮&quot;;    stuArray[2].age=99;    stuArray[2].score=100;//结构体的遍历访问    for(int i=0;i&lt;4;i++)    &#123;        cout&lt;&lt;stuArray[i].name&lt;&lt;&quot;: &quot;        &lt;&lt;stuArray[i].age&lt;&lt;&quot;岁 &quot;        &lt;&lt;stuArray[i].score&lt;&lt;&quot;分&quot;&lt;&lt;endl;     &#125;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h3 id="注意：定义或者创建完结构体之后，末尾要加分号；"><a href="#注意：定义或者创建完结构体之后，末尾要加分号；" class="headerlink" title="注意：定义或者创建完结构体之后，末尾要加分号；"></a>注意：定义或者创建完结构体之后，末尾要加分号；</h3><h3 id="在定义完成结构体之后，后续的结构体在创建和赋值时可以省略关键字struct"><a href="#在定义完成结构体之后，后续的结构体在创建和赋值时可以省略关键字struct" class="headerlink" title="在定义完成结构体之后，后续的结构体在创建和赋值时可以省略关键字struct"></a>在定义完成结构体之后，后续的结构体在创建和赋值时可以省略关键字struct</h3>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用指针实现冒泡排序</title>
    <link href="/2021/11/27/%E7%94%A8%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/11/27/%E7%94%A8%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><pre><code>#include&lt;iostream&gt;using namespace std;void bubbleSort(int *arr,int len);void printArray(int *arr,int len);int main()&#123;    //冒泡排序    int arr[10]=&#123;4,6,8,0,3,7,9,1,5,2&#125;;    bubbleSort(arr,10);    printArray(arr,10);     system(&quot;pause&quot;);    return 0;&#125;void bubbleSort(int *arr,int len)&#123;     for(int i=0;i&lt;len-1;i++)    &#123;        for(int j=0;j&lt;len-i-1;j++)        &#123;            if(arr[j]&gt;arr[j+1])            &#123;                int tem=arr[j];                arr[j]=arr[j+1];                arr[j+1]=tem;            &#125;        &#125;    &#125;&#125;void printArray(int *arr,int len)&#123;    for(int i=0;i&lt;len;i++)    &#123;        cout&lt;&lt;*arr&lt;&lt;endl;        arr++;    &#125;&#125;</code></pre><hr><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><h4 id="在调用函数时，如果传入的是指针，比如数组的指针arr时，可以用arr-i-的形式访问和修改其中的元素"><a href="#在调用函数时，如果传入的是指针，比如数组的指针arr时，可以用arr-i-的形式访问和修改其中的元素" class="headerlink" title="在调用函数时，如果传入的是指针，比如数组的指针arr时，可以用arr[i]的形式访问和修改其中的元素"></a>在调用函数时，如果传入的是指针，比如数组的指针arr时，可以用arr[i]的形式访问和修改其中的元素</h4>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>指针和数组</title>
    <link href="/2021/11/27/%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84/"/>
    <url>/2021/11/27/%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="利用指针访问数组"><a href="#利用指针访问数组" class="headerlink" title="利用指针访问数组"></a>利用指针访问数组</h2><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><pre><code>int arr[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;;int *p=arr;//数组名就是的值就是数组的首地址int i;for(i=0;i&lt;10;i++)&#123;    cout&lt;&lt;*p&lt;&lt;endl;    &#125; </code></pre><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><h3 id="未完待续。。。"><a href="#未完待续。。。" class="headerlink" title="未完待续。。。"></a>未完待续。。。</h3>]]></content>
    
    
    
    <tags>
      
      <tag>C++ 未完待续</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>指针</title>
    <link href="/2021/11/27/%E6%8C%87%E9%92%88/"/>
    <url>/2021/11/27/%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h2 id="指针的作用"><a href="#指针的作用" class="headerlink" title="指针的作用"></a>指针的作用</h2><h4 id="可以通过指针间接访问内存"><a href="#可以通过指针间接访问内存" class="headerlink" title="可以通过指针间接访问内存"></a>可以通过指针间接访问内存</h4><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><h3 id="1-内存编号一般是从0开始记录的，一般用16进制数字表示"><a href="#1-内存编号一般是从0开始记录的，一般用16进制数字表示" class="headerlink" title="1.内存编号一般是从0开始记录的，一般用16进制数字表示"></a>1.内存编号一般是从0开始记录的，一般用16进制数字表示</h3><h3 id="2-可以利用指针变量保存地址"><a href="#2-可以利用指针变量保存地址" class="headerlink" title="2.可以利用指针变量保存地址"></a>2.可以利用指针变量保存地址</h3><hr><h2 id="指针的定义和使用"><a href="#指针的定义和使用" class="headerlink" title="指针的定义和使用"></a>指针的定义和使用</h2><h3 id="1-语法：数据类型-变量名"><a href="#1-语法：数据类型-变量名" class="headerlink" title="1.语法：数据类型 * 变量名"></a>1.语法：数据类型 * 变量名</h3><h4 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h4><pre><code>int a = 10 ;int *p;p = &amp;a;   // 或者 int *p = &amp;a;</code></pre><h3 id="2-指针变量的赋值"><a href="#2-指针变量的赋值" class="headerlink" title="2.指针变量的赋值"></a>2.指针变量的赋值</h3><pre><code>p1=&amp;a;//将a的地址赋给p1cout&lt;&lt;&quot;a的地址：&quot;&lt;&lt;&amp;a&lt;&lt;endl;cout&lt;&lt;&quot;p1的值：&quot;&lt;&lt;p1&lt;&lt;endl; </code></pre><h3 id="3-指针变量的解引用"><a href="#3-指针变量的解引用" class="headerlink" title="3.指针变量的解引用"></a>3.指针变量的解引用</h3><pre><code>cout&lt;&lt;&quot;指针p1指向的数据：&quot;&lt;&lt;*p1&lt;&lt;endl; </code></pre><h3 id="4-指针占用的内存空间"><a href="#4-指针占用的内存空间" class="headerlink" title="4.指针占用的内存空间"></a>4.指针占用的内存空间</h3><pre><code>cout&lt;&lt;&quot;指针p1占用的内存空间：&quot;&lt;&lt;sizeof(p1)&lt;&lt;endl;cout&lt;&lt;&quot;整型指针占用的内存空间：&quot;&lt;&lt;sizeof(int *)&lt;&lt;endl;cout&lt;&lt;&quot;float型指针占用的内存空间：&quot;&lt;&lt;sizeof(float *)&lt;&lt;endl;cout&lt;&lt;&quot;double型指针占用的内存空间：&quot;&lt;&lt;sizeof(double *)&lt;&lt;endl;</code></pre><h4 id="指针变量占用的内存空间不随指向的数据类型的变化而变化。"><a href="#指针变量占用的内存空间不随指向的数据类型的变化而变化。" class="headerlink" title="指针变量占用的内存空间不随指向的数据类型的变化而变化。"></a>指针变量占用的内存空间不随指向的数据类型的变化而变化。</h4><hr><h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><h4 id="指针变量指向内存地址编号为0的空间"><a href="#指针变量指向内存地址编号为0的空间" class="headerlink" title="指针变量指向内存地址编号为0的空间"></a>指针变量指向内存地址编号为0的空间</h4><h3 id="用途：初始化指针变量"><a href="#用途：初始化指针变量" class="headerlink" title="用途：初始化指针变量"></a>用途：初始化指针变量</h3><h3 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h3><h4 id="1-内存地址编号在0-255为系统占用内存，不允许访问"><a href="#1-内存地址编号在0-255为系统占用内存，不允许访问" class="headerlink" title="1.内存地址编号在0~255为系统占用内存，不允许访问"></a>1.内存地址编号在0~255为系统占用内存，不允许访问</h4><h4 id="2-访问空指针会报错"><a href="#2-访问空指针会报错" class="headerlink" title="2.访问空指针会报错"></a>2.访问空指针会报错</h4><pre><code>int *p = NULL;//定义一个空指针</code></pre><hr><h3 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h3><h4 id="指针变量指向了非法的内存空间"><a href="#指针变量指向了非法的内存空间" class="headerlink" title="指针变量指向了非法的内存空间"></a>指针变量指向了非法的内存空间</h4><h4 id="例如：-1"><a href="#例如：-1" class="headerlink" title="例如："></a>例如：</h4><pre><code>int *p；p = 0x1100;//指针p指向的内存空间未经过申请，这个指针是野指针</code></pre><h3 id="注意：程序设计中应尽量避免出现野指针，用野指针进行访问会报错"><a href="#注意：程序设计中应尽量避免出现野指针，用野指针进行访问会报错" class="headerlink" title="注意：程序设计中应尽量避免出现野指针，用野指针进行访问会报错"></a>注意：程序设计中应尽量避免出现野指针，用野指针进行访问会报错</h3><hr><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><pre><code>int a=10;int b=20;</code></pre><h4 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h4><h4 id="特点：指针的指向可以被修改，但是指针指向的值不能被修改-是指不能通过解引用的方式修改指针指向的内容"><a href="#特点：指针的指向可以被修改，但是指针指向的值不能被修改-是指不能通过解引用的方式修改指针指向的内容" class="headerlink" title="特点：指针的指向可以被修改，但是指针指向的值不能被修改(是指不能通过解引用的方式修改指针指向的内容)"></a>特点：指针的指向可以被修改，但是指针指向的值不能被修改(是指不能通过解引用的方式修改指针指向的内容)</h4><pre><code>const int *p1=&amp;a;/*    a=20;//将20赋给变量a是合法的    *p1=20//利用解引用的方式改变p1指向的内容是非法的    p1=&amp;b//可以改变指针p1的指向，让其指向其他内存区域 */</code></pre><h4 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h4><h4 id="特点：指针的指向是不可以被修改的，但是可以用指针修改指针指向的内容"><a href="#特点：指针的指向是不可以被修改的，但是可以用指针修改指针指向的内容" class="headerlink" title="特点：指针的指向是不可以被修改的，但是可以用指针修改指针指向的内容"></a>特点：指针的指向是不可以被修改的，但是可以用指针修改指针指向的内容</h4><pre><code>int *const p2=&amp;a;/*    p2=&amp;b; //将指针指向p2是非法的    *p2=20;//用解引用的方式改变指针p2指向的内存空间的数据是合法的 */ </code></pre><h4 id="const既修饰指针也修饰变量"><a href="#const既修饰指针也修饰变量" class="headerlink" title="const既修饰指针也修饰变量"></a>const既修饰指针也修饰变量</h4><pre><code>const int *const p3 = &amp;a;</code></pre><h4 id="指针的指向不能被修改，也不能用解引用的方式修改指针指向的内容"><a href="#指针的指向不能被修改，也不能用解引用的方式修改指针指向的内容" class="headerlink" title="指针的指向不能被修改，也不能用解引用的方式修改指针指向的内容"></a>指针的指向不能被修改，也不能用解引用的方式修改指针指向的内容</h4><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><h4 id="const修饰哪个，哪个就不能被修改。"><a href="#const修饰哪个，哪个就不能被修改。" class="headerlink" title="const修饰哪个，哪个就不能被修改。"></a>const修饰哪个，哪个就不能被修改。</h4>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二维数组</title>
    <link href="/2021/11/26/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
    <url>/2021/11/26/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="二维数组的定义"><a href="#二维数组的定义" class="headerlink" title="二维数组的定义"></a>二维数组的定义</h2><pre><code>//定义一个2行3列的二维数组 int arr1[2][3];  int arr2[2][3]=&#123;    &#123;1,2,3&#125;,    &#123;4,5,6&#125;&#125;; int arr3[][3]=&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;int arr4[2][3]=&#123;1,2,3,4,5,6&#125;;int arr5[][3]=&#123;1,2,3,4,5,6&#125;;/*以上定义的都是同一个二维数组，arr4和arr5中，计算机会根据给出的列数自动计算出数组的行数 */ </code></pre><h2 id="二维数组的访问"><a href="#二维数组的访问" class="headerlink" title="二维数组的访问"></a>二维数组的访问</h2><pre><code>//访问一个2行3列的数组int i,j;for(i=0;i&lt;2;i++)&#123;    for(j=0;j&lt;3;j++)    &#123;        cout&lt;&lt;arr2[i][j]&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;endl; &#125; </code></pre><h2 id="二维数组名"><a href="#二维数组名" class="headerlink" title="二维数组名"></a>二维数组名</h2><pre><code>int arr[2][3]=&#123;    &#123;1,2,3&#125;,    &#123;4,5,6&#125;&#125;;cout&lt;&lt;&quot;二维数组的首地址是：&quot;&lt;&lt;arr&lt;&lt;endl;cout&lt;&lt;&quot;二维数组占用的内存空间为：&quot;&lt;&lt;sizeof(arr)&lt;&lt;endl;cout&lt;&lt;&quot;二维数组含有的元素个数为：&quot;&lt;&lt;sizeof(arr)/sizeof(arr[0][0])&lt;&lt;endl;cout&lt;&lt;&quot;二维数组第一行的地址为：&quot;&lt;&lt;arr[0]&lt;&lt;endl;cout&lt;&lt;&quot;二维数组第二行第二列的地址为：&quot;&lt;&lt;&amp;arr[0][1]&lt;&lt;endl;cout&lt;&lt;&quot;二维数组第二行的地址为：&quot;&lt;&lt;arr[1]&lt;&lt;endl;cout&lt;&lt;&quot;二维数组第二行的首地址是：&quot;&lt;&lt;&amp;arr[1][0]&lt;&lt;endl;cout&lt;&lt;&quot;二维数组每个元素占用的内存空间为：&quot;&lt;&lt;sizeof(arr[0][0])&lt;&lt;endl;cout&lt;&lt;&quot;二维数组的行数为：&quot;&lt;&lt;sizeof(arr)/sizeof(arr[0])&lt;&lt;endl;cout&lt;&lt;&quot;二维数组的列数为：&quot;&lt;&lt;sizeof(arr[0])/sizeof(arr[0][0])&lt;&lt;endl; </code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数的分文件编写</title>
    <link href="/2021/11/26/%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99/"/>
    <url>/2021/11/26/%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h2 id="1-创建-h后缀名的头文件"><a href="#1-创建-h后缀名的头文件" class="headerlink" title="1.创建.h后缀名的头文件"></a>1.创建.h后缀名的头文件</h2><h2 id="2-创建-cpp后缀名的源文件"><a href="#2-创建-cpp后缀名的源文件" class="headerlink" title="2.创建.cpp后缀名的源文件"></a>2.创建.cpp后缀名的源文件</h2><h2 id="3-在头文件中对函数进行声明"><a href="#3-在头文件中对函数进行声明" class="headerlink" title="3.在头文件中对函数进行声明"></a>3.在头文件中对函数进行声明</h2><h2 id="4-在源文件中对函数进行定义"><a href="#4-在源文件中对函数进行定义" class="headerlink" title="4.在源文件中对函数进行定义"></a>4.在源文件中对函数进行定义</h2><hr><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h2 id="max-h"><a href="#max-h" class="headerlink" title="max.h"></a>max.h</h2><h3 id="include"><a href="#include" class="headerlink" title="#include"></a>#include<iostream></h3><h3 id="using-namespace-std"><a href="#using-namespace-std" class="headerlink" title="using namespace std;"></a>using namespace std;</h3><pre><code>void max(int num1,int num2);</code></pre><hr><h2 id="max-cpp"><a href="#max-cpp" class="headerlink" title="max.cpp"></a>max.cpp</h2><h3 id="include-“max-h”"><a href="#include-“max-h”" class="headerlink" title="#include “max.h”"></a>#include “max.h”</h3><pre><code>void max(int num1,int num2)&#123;    cout&lt;&lt; (num1 &gt; num2 ? num1 : num2)&lt;&lt;endl;&#125;</code></pre><hr><h2 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h2><h3 id="include-1"><a href="#include-1" class="headerlink" title="#include"></a>#include<iostream></h3><h3 id="include-“max-h”-1"><a href="#include-“max-h”-1" class="headerlink" title="#include “max.h”"></a>#include “max.h”</h3><h3 id="using-namespace-std-1"><a href="#using-namespace-std-1" class="headerlink" title="using namespace std;"></a>using namespace std;</h3><pre><code>int main()&#123;    int a=10,b=20;  max(a,b);&#125;</code></pre><hr><h3 id="注意：加粗部分为重点，与C语言有所不同，这里没用-ifndef和-endif，并且在函数源文件中需要调用该函数对应的头文件，因为该头文件已经调用了-include和using-namespace-std-因此在函数的调用中不需要再次进行书写"><a href="#注意：加粗部分为重点，与C语言有所不同，这里没用-ifndef和-endif，并且在函数源文件中需要调用该函数对应的头文件，因为该头文件已经调用了-include和using-namespace-std-因此在函数的调用中不需要再次进行书写" class="headerlink" title="注意：加粗部分为重点，与C语言有所不同，这里没用#ifndef和#endif，并且在函数源文件中需要调用该函数对应的头文件，因为该头文件已经调用了#include和using namespace std ,因此在函数的调用中不需要再次进行书写"></a>注意：加粗部分为重点，与C语言有所不同，这里没用#ifndef和#endif，并且在函数源文件中需要调用该函数对应的头文件，因为该头文件已经调用了#include<iostream>和using namespace std ,因此在函数的调用中不需要再次进行书写</h3>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>goto语句</title>
    <link href="/2021/11/25/goto%E8%AF%AD%E5%8F%A5/"/>
    <url>/2021/11/25/goto%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h2><h3 id="goto语句的作用：无条件跳转"><a href="#goto语句的作用：无条件跳转" class="headerlink" title="goto语句的作用：无条件跳转"></a>goto语句的作用：无条件跳转</h3><h3 id="goto语句的语法："><a href="#goto语句的语法：" class="headerlink" title="goto语句的语法："></a>goto语句的语法：</h3><hr><h4 id="goto-标签名"><a href="#goto-标签名" class="headerlink" title="goto 标签名;"></a>goto 标签名;</h4><h4 id="标签名："><a href="#标签名：" class="headerlink" title="标签名："></a>标签名：</h4><hr><h3 id="注意：第一个标签名后面是分号，第二个标签名后面是冒号。"><a href="#注意：第一个标签名后面是分号，第二个标签名后面是冒号。" class="headerlink" title="注意：第一个标签名后面是分号，第二个标签名后面是冒号。"></a>注意：第一个标签名后面是分号，第二个标签名后面是冒号。</h3><h3 id="标签名一般是大写"><a href="#标签名一般是大写" class="headerlink" title="标签名一般是大写"></a>标签名一般是大写</h3><pre><code>#include&lt;iostream&gt;using namespace std;int main()&#123;    cout&lt;&lt;&quot;first&quot;&lt;&lt;endl;    cout&lt;&lt;&quot;second&quot;&lt;&lt;endl;    goto FLAG;    cout&lt;&lt;&quot;third&quot;&lt;&lt;endl;    cout&lt;&lt;&quot;forth&quot;&lt;&lt;endl;    FLAG:    cout&lt;&lt;&quot;fifth&quot;&lt;&lt;endl;    system(&quot;pause&quot;);    return 0; &#125; </code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一维数组</title>
    <link href="/2021/11/25/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
    <url>/2021/11/25/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="数组的特点："><a href="#数组的特点：" class="headerlink" title="数组的特点："></a>数组的特点：</h3><h4 id="1-数组中的每个数据都是相同的数据类型"><a href="#1-数组中的每个数据都是相同的数据类型" class="headerlink" title="1.数组中的每个数据都是相同的数据类型"></a>1.数组中的每个数据都是相同的数据类型</h4><h4 id="2-数据是由连续的内存位置组成的"><a href="#2-数据是由连续的内存位置组成的" class="headerlink" title="2.数据是由连续的内存位置组成的"></a>2.数据是由连续的内存位置组成的</h4><h4 id="3-数组的下标是从0开始索引的"><a href="#3-数组的下标是从0开始索引的" class="headerlink" title="3.数组的下标是从0开始索引的"></a>3.数组的下标是从0开始索引的</h4><h3 id="数组的三种定义方式"><a href="#数组的三种定义方式" class="headerlink" title="数组的三种定义方式"></a>数组的三种定义方式</h3><h4 id="1-数据类型-数据名-数组长度"><a href="#1-数据类型-数据名-数组长度" class="headerlink" title="1.数据类型 数据名 [数组长度] ;"></a>1.数据类型 数据名 [数组长度] ;</h4><pre><code>    int array[10];//定义一个长度为10的数组</code></pre><h4 id="2-数据类型-数据名-数组长度-值1，值2，值3…"><a href="#2-数据类型-数据名-数组长度-值1，值2，值3…" class="headerlink" title="2.数据类型 数据名 [数组长度] = {值1，值2，值3…};"></a>2.数据类型 数据名 [数组长度] = {值1，值2，值3…};</h4><pre><code>    int array[10]=&#123;10,20,30&#125;;</code></pre><p>   注意：10、20、30会被依次赋给a[0]、a[1]、a[2]，其他未被赋值的会自动被0填充</p><h4 id="3-数据类型-数据名-值1，值2，值3"><a href="#3-数据类型-数据名-值1，值2，值3" class="headerlink" title="3.数据类型 数据名 [] = {值1，值2，值3};"></a>3.数据类型 数据名 [] = {值1，值2，值3};</h4><pre><code>    int array[]=&#123;10,20,30&#125;;</code></pre><p>   这种赋值方式下，系统会自动计算出数组长度。这个数组的长度为3。<br>   一种计算数组长度的方法是:</p><h4 id="cout-lt-lt-sizeof-array-sizeof-array-0-lt-lt-endl"><a href="#cout-lt-lt-sizeof-array-sizeof-array-0-lt-lt-endl" class="headerlink" title="cout&lt;&lt;sizeof(array)/sizeof(array[0])&lt;&lt;endl;"></a>cout&lt;&lt;sizeof(array)/sizeof(array[0])&lt;&lt;endl;</h4><hr><h3 id="数组名的用途"><a href="#数组名的用途" class="headerlink" title="数组名的用途"></a>数组名的用途</h3><pre><code>int array[]=&#123;10,20,30&#125;;</code></pre><h4 id="1-可以通过数组名统计数组占用的内存大小"><a href="#1-可以通过数组名统计数组占用的内存大小" class="headerlink" title="1.可以通过数组名统计数组占用的内存大小"></a>1.可以通过数组名统计数组占用的内存大小</h4><pre><code>cout&lt;&lt;&quot;整个数组占用的内存空间为：&quot;&lt;&lt;sizeof(array)&lt;&lt;endl;cout&lt;&lt;&quot;每个元素占用的内存空间为：&quot;&lt;&lt;sizeof(array[0])&lt;&lt;endl;cout&lt;&lt;&quot;数组中的元素个数为：&quot;&lt;&lt;sizeof(array)/sizeof(array[0])&lt;&lt;endl;</code></pre><h4 id="2-可以通过数组名查看数组首地址"><a href="#2-可以通过数组名查看数组首地址" class="headerlink" title="2.可以通过数组名查看数组首地址"></a>2.可以通过数组名查看数组首地址</h4><pre><code>cout&lt;&lt;&quot;数组的首地址为：&quot;&lt;&lt;array&lt;&lt;endl;cout&lt;&lt;&quot;数组第一个元素的地址为：&quot;&lt;&lt;&amp;array[0]&lt;&lt;endl; </code></pre><h4 id="注意：数组名是一个常量，它指向一段内存空间，不可以进行赋值操作"><a href="#注意：数组名是一个常量，它指向一段内存空间，不可以进行赋值操作" class="headerlink" title="注意：数组名是一个常量，它指向一段内存空间，不可以进行赋值操作"></a>注意：数组名是一个常量，它指向一段内存空间，不可以进行赋值操作</h4><hr><pre><code>//元素逆置int arr[]=&#123;1,2,3,4,5&#125;; int i,j; j=sizeof(arr)/sizeof(arr[0])-1;////i和j分别代表要交换的两个数组元素的左右下标for(i=0;i&lt;j;i++,j--)//循环条件是左下标小于右下标&#123;    int tem;    tem=arr[i];    arr[i]=arr[j];    arr[j]=tem;    &#125; </code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三目运算符</title>
    <link href="/2021/11/24/%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2021/11/24/%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p>/*<br>    表达式1 ? 表达式2 ： 表达式3<br>    如果表达式1为真，则运算结果返回表达式2，否则返回表达式3<br>    三目运算符返回的是变量，返回结果还可以继续被赋值<br>*/</p><p>int a = 10, b = 20;<br>int c;<br>c = (a &gt; b ? a : b);  //将a和b中较大的数值赋给c<br>cout &lt;&lt; “c=” &lt;&lt; c &lt;&lt; endl;</p><p>(a &lt; b ? a : b) = 100;//将a和b中较小的变量赋值为100<br>cout &lt;&lt; “a=” &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; “b=” &lt;&lt; b &lt;&lt; endl;</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>switch语句</title>
    <link href="/2021/11/24/switch%E8%AF%AD%E5%8F%A5/"/>
    <url>/2021/11/24/switch%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><pre><code>/*    示例：给电影打分 十分制    9~10分  经典    7~8分 非常好    5~6分 一般    低于5分 烂片*/</code></pre><h4 id="1-switch语句的表达式类型只能是整型或字符型的"><a href="#1-switch语句的表达式类型只能是整型或字符型的" class="headerlink" title="1. switch语句的表达式类型只能是整型或字符型的"></a>1. switch语句的表达式类型只能是整型或字符型的</h4><h4 id="2-case里如果没有break，那么程序会一直向下执行"><a href="#2-case里如果没有break，那么程序会一直向下执行" class="headerlink" title="2. case里如果没有break，那么程序会一直向下执行"></a>2. case里如果没有break，那么程序会一直向下执行</h4><h4 id="3-与if语句相比，switch语句在进行多条件判断的时候，结构更加清晰，执行效率更高"><a href="#3-与if语句相比，switch语句在进行多条件判断的时候，结构更加清晰，执行效率更高" class="headerlink" title="3. 与if语句相比，switch语句在进行多条件判断的时候，结构更加清晰，执行效率更高"></a>3. 与if语句相比，switch语句在进行多条件判断的时候，结构更加清晰，执行效率更高</h4><h4 id="4-switch语句的缺点是不能判断区间"><a href="#4-switch语句的缺点是不能判断区间" class="headerlink" title="4. switch语句的缺点是不能判断区间"></a>4. switch语句的缺点是不能判断区间</h4><pre><code>int score = 0;cout &lt;&lt; &quot;请输入您要打的分数：&quot;;cin &gt;&gt; score;cout &lt;&lt; &quot;您输入的分数是：&quot; &lt;&lt; score &lt;&lt; endl;switch (score)&#123;case 10:    cout &lt;&lt; &quot;您认为是经典电影&quot; &lt;&lt; endl; break;case 9:    cout &lt;&lt; &quot;您认为是经典电影&quot; &lt;&lt; endl; break;case 7:    cout &lt;&lt; &quot;您认为电影非常好&quot; &lt;&lt; endl; break;case 8:    cout &lt;&lt; &quot;您认为电影非常好&quot; &lt;&lt; endl; break;case 5:    cout &lt;&lt; &quot;您认为电影一般&quot; &lt;&lt; endl; break;case 6:    cout &lt;&lt; &quot;您认为电影一般&quot; &lt;&lt; endl; break;default:    cout &lt;&lt; &quot;您认为这是部烂片&quot; &lt;&lt; endl; break;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逻辑运算符</title>
    <link href="/2021/11/24/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2021/11/24/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><h2 id="非"><a href="#非" class="headerlink" title="非 !"></a>非 !</h2><p>   //若a为真，则!a为假；若a为假，则!a为真<br>    int a = 10;<br>    cout &lt;&lt; !a &lt;&lt; endl;<br>    cout &lt;&lt; !!a &lt;&lt; endl;</p><h2 id="或"><a href="#或" class="headerlink" title="或 ||"></a>或 ||</h2><pre><code>//a||b,a或b有真即为真，都为假则为假int b = 0;cout &lt;&lt;( a || b) &lt;&lt; endl;</code></pre><h2 id="与-amp-amp"><a href="#与-amp-amp" class="headerlink" title="与 &amp;&amp;"></a>与 &amp;&amp;</h2><pre><code>//a&amp;&amp;b,两者都为真才为真，有假则为假cout &lt;&lt;( a&amp;&amp;b) &lt;&lt; endl;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>比较运算符</title>
    <link href="/2021/11/24/%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2021/11/24/%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><h3 id="等于"><a href="#等于" class="headerlink" title="等于 =="></a>等于 ==</h3><pre><code>cout &lt;&lt; (a == b) &lt;&lt; endl;</code></pre><h2 id="不等于"><a href="#不等于" class="headerlink" title="不等于 !="></a>不等于 !=</h2><pre><code>cout &lt;&lt; (a != b) &lt;&lt; endl;</code></pre><h2 id="大于-gt"><a href="#大于-gt" class="headerlink" title="大于 &gt;"></a>大于 &gt;</h2><pre><code>cout &lt;&lt; (a &gt; b) &lt;&lt; endl;</code></pre><h2 id="小于-lt"><a href="#小于-lt" class="headerlink" title="小于 &lt;"></a>小于 &lt;</h2><pre><code>cout &lt;&lt; (a &lt; b) &lt;&lt; endl;</code></pre><h2 id="大于等于-gt"><a href="#大于等于-gt" class="headerlink" title="大于等于 &gt;="></a>大于等于 &gt;=</h2><pre><code>cout &lt;&lt; (a &gt;= b) &lt;&lt; endl;</code></pre><h2 id="小于等于-lt"><a href="#小于等于-lt" class="headerlink" title="小于等于 &lt;="></a>小于等于 &lt;=</h2><pre><code>cout &lt;&lt; (a &lt;= b) &lt;&lt; endl;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>赋值运算符</title>
    <link href="/2021/11/24/%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2021/11/24/%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><h3 id=""><a href="#" class="headerlink" title="="></a>=</h3><pre><code>int a;a = 10;cout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; endl;</code></pre><h2 id="-1"><a href="#-1" class="headerlink" title="+="></a>+=</h2><pre><code>int b = 10;b += 1;  //相当于将b+1的值赋给bcout &lt;&lt; &quot;b=&quot; &lt;&lt; b &lt;&lt; endl;</code></pre><h2 id="-2"><a href="#-2" class="headerlink" title="-="></a>-=</h2><pre><code>int c = 10;c -= 1; cout &lt;&lt; &quot;c=&quot; &lt;&lt; c &lt;&lt; endl;</code></pre><h2 id="-3"><a href="#-3" class="headerlink" title="*="></a>*=</h2><pre><code>int d = 10;d *= 2;cout &lt;&lt; &quot;d=&quot; &lt;&lt; d &lt;&lt; endl;</code></pre><h2 id="-4"><a href="#-4" class="headerlink" title="/="></a>/=</h2><pre><code>double e = 10;e /= 2;cout &lt;&lt; &quot;e=&quot; &lt;&lt; e &lt;&lt; endl;</code></pre><h2 id="-5"><a href="#-5" class="headerlink" title="%="></a>%=</h2><pre><code>int f = 10;f %= 3;cout &lt;&lt; &quot;f=&quot; &lt;&lt; f &lt;&lt; endl;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运算符</title>
    <link href="/2021/11/24/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2021/11/24/%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="加法"><a href="#加法" class="headerlink" title="加法 +"></a>加法 +</h3><pre><code>//加法 +int num1 = 10, num2 = 3;cout &lt;&lt; num1 + num2 &lt;&lt; endl;</code></pre><h3 id="减法"><a href="#减法" class="headerlink" title="减法 -"></a>减法 -</h3><pre><code>//减法cout &lt;&lt; num1 - num2 &lt;&lt; endl;</code></pre><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法 *"></a>乘法 *</h3><pre><code>//乘法cout &lt;&lt; num1*num2 &lt;&lt; endl;</code></pre><h3 id="除法"><a href="#除法" class="headerlink" title="除法 /"></a>除法 /</h3><pre><code>//除法cout &lt;&lt; num1 / num2 &lt;&lt; endl;//两个整数相除的运算结果只保留整数位/*被除数不能为0，否则会报错int num3 = 0;cout &lt;&lt; num1 / num3 &lt;&lt; endl;*///两个小数相除double num3 = 3.0;cout &lt;&lt; num1/num3 &lt;&lt; endl;</code></pre><h3 id="取余"><a href="#取余" class="headerlink" title="取余 %"></a>取余 %</h3><pre><code>//取余cout &lt;&lt; num1%num2 &lt;&lt; endl;</code></pre><h3 id="前置递增"><a href="#前置递增" class="headerlink" title="前置递增"></a>前置递增</h3><pre><code>// 前置递增int a1 = 10;++a1;cout &lt;&lt;&quot;a1=&quot; &lt;&lt; a1 &lt;&lt; endl;</code></pre><h3 id="后置递增"><a href="#后置递增" class="headerlink" title="后置递增"></a>后置递增</h3><pre><code>//后置递增int b1 = 10;b1++;cout &lt;&lt;&quot;b1=&quot; &lt;&lt; b1 &lt;&lt; endl;</code></pre><h3 id="前置和后置的区别"><a href="#前置和后置的区别" class="headerlink" title="前置和后置的区别"></a>前置和后置的区别</h3><pre><code>/*前置递增是先让操作数加1，再进行表达式的运算；后置递增是先进行表达数的运算，再将其加1 */int a2 = 5, b2 = 5;cout &lt;&lt; &quot;a2=&quot; &lt;&lt; ++a2 &lt;&lt; endl;//前置cout &lt;&lt; &quot;b2=&quot; &lt;&lt; b2++ &lt;&lt; endl;//后置</code></pre><h3 id="前置和后置递减同理"><a href="#前置和后置递减同理" class="headerlink" title="前置和后置递减同理"></a>前置和后置递减同理</h3>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据的输入</title>
    <link href="/2021/11/24/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BE%93%E5%85%A5/"/>
    <url>/2021/11/24/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BE%93%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="数据的输入"><a href="#数据的输入" class="headerlink" title="数据的输入"></a>数据的输入</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><pre><code>int num = 1;cout &lt;&lt; &quot;请输入整数的值：&quot; &lt;&lt; endl;cin &gt;&gt; num;cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;</code></pre><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><pre><code>float num = 3.14l;cout &lt;&lt; &quot;请输入num的数值：&quot; &lt;&lt; endl;cin &gt;&gt; num;cout &lt;&lt; &quot;num=&quot; &lt;&lt; num&lt;&lt;endl;</code></pre><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><pre><code>char ch = &#39;A&#39;;cout &lt;&lt; &quot;请输入ch的字符：&quot; &lt;&lt; endl;cin &gt;&gt; ch;cout &lt;&lt; &quot;ch=&quot; &lt;&lt; ch &lt;&lt; endl;</code></pre><h3 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h3><pre><code>string str = &quot;hello&quot;;cout &lt;&lt; &quot;请输入字符串：&quot; &lt;&lt; endl;cin &gt;&gt; str;cout &lt;&lt; &quot;str=&quot; &lt;&lt; str &lt;&lt; endl;</code></pre><h3 id="bool型"><a href="#bool型" class="headerlink" title="bool型"></a>bool型</h3><pre><code>bool flag = false;cout &lt;&lt; &quot;请输入flag的值&quot; &lt;&lt; endl;cin &gt;&gt; flag;cout &lt;&lt; &quot;flag=&quot; &lt;&lt; flag &lt;&lt; endl;</code></pre><hr>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2021/11/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2021/11/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><h3 id="short-int-long-long-long"><a href="#short-int-long-long-long" class="headerlink" title="short; int;  long;   long long"></a>short; int;  long;   long long</h3><pre><code>short 占2个字节cout &lt;&lt; &quot;short占的字节:&quot; &lt;&lt; sizeof(short) &lt;&lt; endl;int 占4个字节cout &lt;&lt; &quot;int占的字节：&quot; &lt;&lt; sizeof(int) &lt;&lt; endl;long占4个字节 cout &lt;&lt; &quot;long占的字节：&quot; &lt;&lt; sizeof(long) &lt;&lt; endl;long long 占8个字节cout &lt;&lt; &quot;long long占的字节：&quot; &lt;&lt; sizeof(long long) &lt;&lt; endl;</code></pre><h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><h3 id="float；-double"><a href="#float；-double" class="headerlink" title="float； double"></a>float； double</h3><pre><code>cout &lt;&lt; &quot;float占的字节：&quot; &lt;&lt; sizeof(float) &lt;&lt; endl;cout &lt;&lt; &quot;double占的字节：&quot; &lt;&lt; sizeof(double) &lt;&lt; endl;float num1 = 3.14;//如果直接这样定义，系统会认为这是一个double类型的数字，鼠标放在3.14上会显示doublefloat num2 = 3.14f;//数字后面加f表示num2是float型数字，而不是    float型，鼠标放在3.14上会显示float</code></pre><h2 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h2><h3 id="char"><a href="#char" class="headerlink" title="char"></a>char</h3><pre><code>/* 字符型变量并不是将字符本身存放在内存中，而是将其对应的ASCII码    值放在存储单元*/char ch = &#39;A&#39;;   cout &lt;&lt; (int)ch &lt;&lt; endl;//强制转换成整型输出cout &lt;&lt; ch &lt;&lt; endl;cout &lt;&lt; &quot;char占的字节：&quot; &lt;&lt; sizeof(char) &lt;&lt; endl;string str1 = &quot;hello world&quot;;//C++风格的字符串定义，需要添加加string头文件                            //定义格式是： string = &quot;字符串&quot;cout &lt;&lt; str1 &lt;&lt; endl;char str2[] = &quot;Hello World&quot;;//C风格的字符串定义                            //定义格式是： char 变量名 [] = &quot;字符串&quot;cout &lt;&lt; str2 &lt;&lt; endl;</code></pre><h2 id="反义字符"><a href="#反义字符" class="headerlink" title="反义字符"></a>反义字符</h2><h3 id="“-“"><a href="#“-“" class="headerlink" title="“\“"></a>“\“</h3><pre><code>cout &lt;&lt; &quot;\\&quot; &lt;&lt; endl;//输出反斜杠&quot;\&quot;,用反义字符“\\”表示</code></pre><h3 id="“-“-1"><a href="#“-“-1" class="headerlink" title="“/“"></a>“/“</h3><pre><code>cout &lt;&lt; &quot;\/&quot; &lt;&lt; endl;//输出反斜杠“/”，用反义字符“\/”表示</code></pre><h3 id="“-t”"><a href="#“-t”" class="headerlink" title="“\t”"></a>“\t”</h3><pre><code>cout &lt;&lt; &quot;hello\tworld\t&quot; &lt;&lt; endl;//制表字符，字符占据一个tab位，并且左对齐,一个tab占八个字符位置cout &lt;&lt; &quot;good\tmorning\t&quot; &lt;&lt; endl;cout &lt;&lt; &quot;hurry\tup\t&quot; &lt;&lt; endl;</code></pre><h3 id="“-t”-1"><a href="#“-t”-1" class="headerlink" title="“\t”"></a>“\t”</h3><pre><code>cout &lt;&lt; &quot;hello world\n&quot;;//换行字符“\n”</code></pre><h2 id="bool类型"><a href="#bool类型" class="headerlink" title="bool类型"></a>bool类型</h2><h3 id="true-false"><a href="#true-false" class="headerlink" title="true false"></a>true false</h3><pre><code>//布尔类型（bool)只有两个值：0和1bool flag1 = true;//创建bool类型数据，true代表1cout &lt;&lt; flag1 &lt;&lt; endl;bool flag2 = false;//创建bool类型数据，false代表0cout &lt;&lt; flag2 &lt;&lt; endl;cout &lt;&lt; &quot;true占的字节&quot; &lt;&lt; sizeof(bool) &lt;&lt; endl;</code></pre><hr>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一篇博客</title>
    <link href="/2021/11/22/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/11/22/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="title-测试功能"><a href="#title-测试功能" class="headerlink" title="title: 测试功能"></a>title: 测试功能</h2><p>这是我的第一篇博客。这个词–&gt;<a href="https://user.qzone.qq.com/2474028599/infocenter">QQ</a>是一个链接，点击它可以来到我的qq空间。</p><h2 id="日程安排"><a href="#日程安排" class="headerlink" title="日程安排"></a>日程安排</h2><h3 id="星期一"><a href="#星期一" class="headerlink" title="星期一"></a>星期一</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">微积分和线性代数<br></code></pre></td></tr></table></figure><p>详细信息: <a href="http://www5.zzu.edu.cn/jwc/">ZZU</a></p><h3 id="星期二"><a href="#星期二" class="headerlink" title="星期二"></a>星期二</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">体育课 英语presentation<br></code></pre></td></tr></table></figure><p>过两天放个链接: [视频]</p><h3 id="星期三"><a href="#星期三" class="headerlink" title="星期三"></a>星期三</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">有个英语对话，但是我还没有准备<br></code></pre></td></tr></table></figure><p>没有链接了</p><h3 id="星期四"><a href="#星期四" class="headerlink" title="星期四"></a>星期四</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">周四的课程记不住了，老年人只能记住48小时以内的一小部分课程<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
